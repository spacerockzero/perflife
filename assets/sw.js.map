{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","assets/js/sw/index.js","node_modules/serviceworker-cache-polyfill/index.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"sw.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* global caches, clients*/\n\n'use strict';\n\n/*serviceworker polyfill*/\nrequire('serviceworker-cache-polyfill');\n\nvar version = 'v2';\nconsole.log('version:', version);\nvar staticCacheName = 'photos-static-' + version;\n\n\nself.oninstall = function(event) {\n  // canary-only feature\n  self.skipWaiting();\n\n  event.waitUntil(\n    caches.open(staticCacheName).then(function(cache){\n      // install these files as dependencies\n      return cache.addAll([\n        './',\n        './_dist/css/all.css',\n        './_dist/js/page.js',\n        './_dist/img/apple-touch-icon.png',\n        './_dist/img/icon.png'\n      ]);\n    })\n  );\n};\n\n\nvar expectedCaches = [\n  staticCacheName,\n  'photos-imgs',\n  'photos-data'\n];\n\n\nself.onactivate = function(event) {\n  // canary-only feature\n  if (self.clients && clients.claim) {\n    clients.claim();\n  }\n\n  // remove caches beginning \"photos-\" that aren't in expectedCaches\n  event.waitUntil(\n    caches.keys().then(function(cacheNames) {\n      return Promise.all(\n        cacheNames.map(function(cacheName) {\n          if (/^photos-/.test(cacheName) && expectedCaches.indexOf(cacheName) === -1) {\n            return caches.delete(cacheName);\n          }\n        })\n      );\n    })\n  );\n};\n\nself.onfetch = function(event) {\n  var requestURL = new URL(event.request.url);\n  // // console.log('requestURL.pathname:', requestURL.pathname)\n  // // debugger;\n  if (/\\api\\/photos/.test(requestURL.pathname)) {\n    console.log('match: api data');\n    event.respondWith(apiResponse(event.request));\n  }\n  else if (/\\img\\/api/.test(requestURL.pathname)) {\n    console.log('match: profile img');\n    event.respondWith(imgResponse(event.request));\n  }\n  else {\n    event.respondWith(\n      caches.match(event.request).then(function(response) {\n        return response || fetch(event.request);\n      })\n    );\n  }\n};\n\n\nfunction apiResponse(request) {\n  if (request.headers.get('x-use-cache-only')) {\n    return caches.match(request);\n  }\n  return fetch(request).then(function(response) {\n    return caches.open('photos-data').then(function(cache) {\n      // clean up the image cache\n      Promise.all([\n        response.clone().json(),\n        caches.open('photos-imgs')\n      ]).then(function(results) {\n        var data = results[0];\n        var imgCache = results[1];\n\n        var imgURLs = data.map(function(photo){\n          return photo.thumbnailUrl;\n        });\n\n        // if an item in the cache *isn't* in imgURLs, delete it\n        imgCache.keys().then(function(requests) {\n          requests.forEach(function(request) {\n            if (imgURLs.indexOf(request.url) == -1) {\n              imgCache.delete(request);\n            }\n          });\n        });\n      });\n\n      cache.put(request, response.clone());\n\n      return response;\n    });\n  });\n}\n\nfunction imgResponse(request) {\n  return caches.match(request).then(function(response) {\n    if (response) {\n      return response;\n    }\n\n    return fetch(request).then(function(response) {\n      caches.open('photos-imgs').then(function(cache) {\n        cache.put(request, response);\n      });\n\n      return response.clone();\n    });\n  });\n}\n","if (!Cache.prototype.add) {\n  Cache.prototype.add = function add(request) {\n    return this.addAll([request]);\n  };\n}\n\nif (!Cache.prototype.addAll) {\n  Cache.prototype.addAll = function addAll(requests) {\n    var cache = this;\n\n    // Since DOMExceptions are not constructable:\n    function NetworkError(message) {\n      this.name = 'NetworkError';\n      this.code = 19;\n      this.message = message;\n    }\n    NetworkError.prototype = Object.create(Error.prototype);\n\n    return Promise.resolve().then(function() {\n      if (arguments.length < 1) throw new TypeError();\n      \n      // Simulate sequence<(Request or USVString)> binding:\n      var sequence = [];\n\n      requests = requests.map(function(request) {\n        if (request instanceof Request) {\n          return request;\n        }\n        else {\n          return String(request); // may throw TypeError\n        }\n      });\n\n      return Promise.all(\n        requests.map(function(request) {\n          if (typeof request === 'string') {\n            request = new Request(request);\n          }\n\n          var scheme = new URL(request.url).protocol;\n\n          if (scheme !== 'http:' && scheme !== 'https:') {\n            throw new NetworkError(\"Invalid scheme\");\n          }\n\n          return fetch(request.clone());\n        })\n      );\n    }).then(function(responses) {\n      // TODO: check that requests don't overwrite one another\n      // (don't think this is possible to polyfill due to opaque responses)\n      return Promise.all(\n        responses.map(function(response, i) {\n          return cache.put(requests[i], response);\n        })\n      );\n    }).then(function() {\n      return undefined;\n    });\n  };\n}\n"]}